/*
 * Web Application Firewall API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SingleWaf {
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    /// Identification name for WAF Rule Set.
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "mode", skip_serializing_if = "Option::is_none")]
    pub mode: Option<Mode>,
    #[serde(rename = "active", skip_serializing_if = "Option::is_none")]
    pub active: Option<bool>,
    #[serde(rename = "sql_injection", skip_serializing_if = "Option::is_none")]
    pub sql_injection: Option<bool>,
    #[serde(rename = "sql_injection_sensitivity", skip_serializing_if = "Option::is_none")]
    pub sql_injection_sensitivity: Option<crate::models::WafSensitivityChoices>,
    #[serde(rename = "remote_file_inclusion", skip_serializing_if = "Option::is_none")]
    pub remote_file_inclusion: Option<bool>,
    #[serde(rename = "remote_file_inclusion_sensitivity", skip_serializing_if = "Option::is_none")]
    pub remote_file_inclusion_sensitivity: Option<crate::models::WafSensitivityChoices>,
    #[serde(rename = "directory_traversal", skip_serializing_if = "Option::is_none")]
    pub directory_traversal: Option<bool>,
    #[serde(rename = "directory_traversal_sensitivity", skip_serializing_if = "Option::is_none")]
    pub directory_traversal_sensitivity: Option<crate::models::WafSensitivityChoices>,
    #[serde(rename = "cross_site_scripting", skip_serializing_if = "Option::is_none")]
    pub cross_site_scripting: Option<bool>,
    #[serde(rename = "cross_site_scripting_sensitivity", skip_serializing_if = "Option::is_none")]
    pub cross_site_scripting_sensitivity: Option<crate::models::WafSensitivityChoices>,
    #[serde(rename = "evading_tricks", skip_serializing_if = "Option::is_none")]
    pub evading_tricks: Option<bool>,
    #[serde(rename = "evading_tricks_sensitivity", skip_serializing_if = "Option::is_none")]
    pub evading_tricks_sensitivity: Option<crate::models::WafSensitivityChoices>,
    #[serde(rename = "file_upload", skip_serializing_if = "Option::is_none")]
    pub file_upload: Option<bool>,
    #[serde(rename = "file_upload_sensitivity", skip_serializing_if = "Option::is_none")]
    pub file_upload_sensitivity: Option<crate::models::WafSensitivityChoices>,
    #[serde(rename = "unwanted_access", skip_serializing_if = "Option::is_none")]
    pub unwanted_access: Option<bool>,
    #[serde(rename = "unwanted_access_sensitivity", skip_serializing_if = "Option::is_none")]
    pub unwanted_access_sensitivity: Option<crate::models::WafSensitivityChoices>,
    #[serde(rename = "identified_attack", skip_serializing_if = "Option::is_none")]
    pub identified_attack: Option<bool>,
    #[serde(rename = "identified_attack_sensitivity", skip_serializing_if = "Option::is_none")]
    pub identified_attack_sensitivity: Option<crate::models::WafSensitivityChoices>,
    #[serde(rename = "bypass_addresses", skip_serializing_if = "Option::is_none")]
    pub bypass_addresses: Option<Vec<String>>,
}

impl SingleWaf {
    pub fn new() -> SingleWaf {
        SingleWaf {
            id: None,
            name: None,
            mode: None,
            active: None,
            sql_injection: None,
            sql_injection_sensitivity: None,
            remote_file_inclusion: None,
            remote_file_inclusion_sensitivity: None,
            directory_traversal: None,
            directory_traversal_sensitivity: None,
            cross_site_scripting: None,
            cross_site_scripting_sensitivity: None,
            evading_tricks: None,
            evading_tricks_sensitivity: None,
            file_upload: None,
            file_upload_sensitivity: None,
            unwanted_access: None,
            unwanted_access_sensitivity: None,
            identified_attack: None,
            identified_attack_sensitivity: None,
            bypass_addresses: None,
        }
    }
}

/// 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Mode {
    #[serde(rename = "blocking")]
    Blocking,
    #[serde(rename = "counting")]
    Counting,
}

impl Default for Mode {
    fn default() -> Mode {
        Self::Blocking
    }
}

